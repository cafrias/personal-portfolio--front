<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico">
    <!--
      Notice the use of %PUBLIC_URL% in the tag above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <link onload="this.rel = 'stylesheet'" href="https://fonts.googleapis.com/css?family=Raleway:400,700,900" rel="preload" as="style" crossorigin>
    <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway:400,700,900"></noscript>
    <title>Carlos Frias | Full-stack Developer</title>
    <!-- Adding polyfill for rel=preload -->
    <script>
      /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
      (function(w){
      	"use strict";
      	/* exported loadCSS */
      	var loadCSS = function( href, before, media ){
      		// Arguments explained:
      		// `href` [REQUIRED] is the URL for your CSS file.
      		// `before` [OPTIONAL] is the element the script should use as a reference for injecting our stylesheet <link> before
      			// By default, loadCSS attempts to inject the link after the last stylesheet or script in the DOM. However, you might desire a more specific location in your document.
      		// `media` [OPTIONAL] is the media type or query of the stylesheet. By default it will be 'all'
      		var doc = w.document;
      		var ss = doc.createElement( "link" );
      		var ref;
      		if( before ){
      			ref = before;
      		}
      		else {
      			var refs = ( doc.body || doc.getElementsByTagName( "head" )[ 0 ] ).childNodes;
      			ref = refs[ refs.length - 1];
      		}

      		var sheets = doc.styleSheets;
      		ss.rel = "stylesheet";
      		ss.href = href;
      		// temporarily set media to something inapplicable to ensure it'll fetch without blocking render
      		ss.media = "only x";

      		// wait until body is defined before injecting link. This ensures a non-blocking load in IE11.
      		function ready( cb ){
      			if( doc.body ){
      				return cb();
      			}
      			setTimeout(function(){
      				ready( cb );
      			});
      		}
      		// Inject link
      			// Note: the ternary preserves the existing behavior of "before" argument, but we could choose to change the argument to "after" in a later release and standardize on ref.nextSibling for all refs
      			// Note: `insertBefore` is used instead of `appendChild`, for safety re: http://www.paulirish.com/2011/surefire-dom-element-insertion/
      		ready( function(){
      			ref.parentNode.insertBefore( ss, ( before ? ref : ref.nextSibling ) );
      		});
      		// A method (exposed on return object for external use) that mimics onload by polling document.styleSheets until it includes the new sheet.
      		var onloadcssdefined = function( cb ){
      			var resolvedHref = ss.href;
      			var i = sheets.length;
      			while( i-- ){
      				if( sheets[ i ].href === resolvedHref ){
      					return cb();
      				}
      			}
      			setTimeout(function() {
      				onloadcssdefined( cb );
      			});
      		};

      		function loadCB(){
      			if( ss.addEventListener ){
      				ss.removeEventListener( "load", loadCB );
      			}
      			ss.media = media || "all";
      		}

      		// once loaded, set link's media back to `all` so that the stylesheet applies once it loads
      		if( ss.addEventListener ){
      			ss.addEventListener( "load", loadCB);
      		}
      		ss.onloadcssdefined = onloadcssdefined;
      		onloadcssdefined( loadCB );
      		return ss;
      	};
      	// commonjs
      	if( typeof exports !== "undefined" ){
      		exports.loadCSS = loadCSS;
      	}
      	else {
      		w.loadCSS = loadCSS;
      	}
      }( typeof global !== "undefined" ? global : this ));

      /*! loadCSS rel=preload polyfill. [c]2017 Filament Group, Inc. MIT License */
      (function( w ){
        // rel=preload support test
        if( !w.loadCSS ){
          return;
        }
        var rp = loadCSS.relpreload = {};
        rp.support = function(){
          try {
            return w.document.createElement( "link" ).relList.supports( "preload" );
          } catch (e) {
            return false;
          }
        };

        // loop preload links and fetch using loadCSS
        rp.poly = function(){
          var links = w.document.getElementsByTagName( "link" );
          for( var i = 0; i < links.length; i++ ){
            var link = links[ i ];
            if( link.rel === "preload" && link.getAttribute( "as" ) === "style" ){
              w.loadCSS( link.href, link, link.getAttribute( "media" ) );
              link.rel = null;
            }
          }
        };

        // if link[rel=preload] is not supported, we must fetch the CSS manually using loadCSS
        if( !rp.support() ){
          rp.poly();
          var run = w.setInterval( rp.poly, 300 );
          if( w.addEventListener ){
            w.addEventListener( "load", function(){
              rp.poly();
              w.clearInterval( run );
            } );
          }
          if( w.attachEvent ){
            w.attachEvent( "onload", function(){
              w.clearInterval( run );
            } );
          }
        }
      }( this ));
    </script>
  </head>
  <body>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start`.
      To create a production bundle, use `npm run build`.
    -->
  </body>
</html>
